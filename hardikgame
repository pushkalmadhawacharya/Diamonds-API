from __future__ import annotations

import random
import secrets
from dataclasses import dataclass, field
from enum import Enum
from threading import Lock
from typing import Dict, List, Optional

try:
    import ssl as _ssl
    SSL_AVAILABLE = True
except ModuleNotFoundError:
    SSL_AVAILABLE = False

from pydantic import BaseModel, Field, constr
try:
    from pydantic import ConfigDict
    _HAS_PYDANTIC_V2 = True
except Exception:
    ConfigDict = None  # type: ignore
    _HAS_PYDANTIC_V2 = False

if SSL_AVAILABLE:
    from fastapi import Depends, FastAPI, HTTPException, Header
    try:
        from fastapi.testclient import TestClient
    except Exception:
        TestClient = None  # type: ignore
else:
    class HTTPException(Exception):  # type: ignore
        def __init__(self, status_code: int, detail: str):
            self.status_code = status_code
            self.detail = detail
            super().__init__(f"{status_code}: {detail}")
    def Depends(x):  # type: ignore
        return x
    def Header(default=None, alias: Optional[str] = None):  # type: ignore
        return default
    class _NoOpApp:  # type: ignore
        def __init__(self, *_, **__):
            pass
        def get(self, *_, **__):
            def deco(f):
                return f
            return deco
        def post(self, *_, **__):
            def deco(f):
                return f
            return deco
    FastAPI = _NoOpApp  # type: ignore
    TestClient = None   # type: ignore

class GameState(str, Enum):
    CREATED = "created"
    RUNNING = "running"
    FINISHED = "finished"
    ABANDONED = "abandoned"

def _token(prefix: str = "tok") -> str:
    return f"{prefix}_" + secrets.token_urlsafe(16)

def _rand_name(prefix: str) -> str:
    return prefix + "_" + secrets.token_hex(3)

@dataclass
class Player:
    player_id: str
    name: str
    is_bot: bool
    token: str
    score: int = 0
    eliminated: bool = False

@dataclass
class Game:
    game_id: str
    admin_token: str
    target_score: int = 20
    round: int = 0
    state: GameState = GameState.CREATED
    players: Dict[str, Player] = field(default_factory=dict)
    winner_id: Optional[str] = None
    def public_scoreboard(self) -> List[dict]:
        return [
            {
                "player_id": p.player_id,
                "name": p.name,
                "is_bot": p.is_bot,
                "score": p.score,
                "eliminated": p.eliminated,
            }
            for p in self.players.values()
        ]

class Store:
    def __init__(self):
        self.games: Dict[str, Game] = {}
        self._lock = Lock()
    def create_game(self, game: Game) -> Game:
        with self._lock:
            self.games[game.game_id] = game
            return game
    def get(self, game_id: str) -> Game:
        g = self.games.get(game_id)
        if not g:
            raise KeyError("game not found")
        return g
    def delete(self, game_id: str):
        with self._lock:
            if game_id in self.games:
                del self.games[game_id]

STORE = Store()

NameStr = constr(strip_whitespace=True, min_length=1, max_length=40)

class NewPlayer(BaseModel):
    name: NameStr

class CreateGameRequest(BaseModel):
    human_players: List[NewPlayer] = Field(default_factory=list)
    bot_count: int = Field(0, ge=0, le=32)
    target_score: int = Field(20, ge=5, le=200)

class CreateGameResponse(BaseModel):
    game_id: str
    admin_token: str
    player_tokens: Dict[str, str]

class StartGameResponse(BaseModel):
    game_id: str
    state: GameState
    round: int

class PublicGameView(BaseModel):
    game_id: str
    state: GameState
    round: int
    target_score: int
    scoreboard: List[dict]
    winner_id: Optional[str]

class PrivatePlayerStatus(BaseModel):
    player_id: str
    name: str
    is_bot: bool
    score: int
    eliminated: bool

class AdvanceResponse(BaseModel):
    game_id: str
    state: GameState
    round: int
    rolls: Dict[str, int]
    winner_id: Optional[str]

class AbandonResponse(BaseModel):
    game_id: str
    state: GameState

class AuthContext(BaseModel):
    role: str
    game: Game
    player: Optional[Player] = None
    if _HAS_PYDANTIC_V2:
        model_config = ConfigDict(arbitrary_types_allowed=True)  # type: ignore
    else:
        class Config:
            arbitrary_types_allowed = True

def get_auth(
    game_id: str,
    x_auth_token: Optional[str] = Header(default=None, alias="X-Auth-Token"),
) -> AuthContext:
    try:
        game = STORE.get(game_id)
    except KeyError:
        raise HTTPException(status_code=404, detail="game not found")
    if not x_auth_token:
        return AuthContext(role="anonymous", game=game)
    if x_auth_token == game.admin_token:
        return AuthContext(role="admin", game=game)
    for p in game.players.values():
        if p.token == x_auth_token:
            return AuthContext(role="player", game=game, player=p)
    raise HTTPException(status_code=401, detail="invalid token for this game")

app = FastAPI(title="Game Service", version="1.1.1")

@app.get("/health")
def health():
    return {"ok": True, "ssl_available": SSL_AVAILABLE}

@app.post("/games", response_model=CreateGameResponse)
def create_game(req: CreateGameRequest):
    game_id = secrets.token_hex(8)
    admin_token = _token("admin")
    players: Dict[str, Player] = {}
    for user in req.human_players:
        pid = secrets.token_hex(4)
        players[pid] = Player(player_id=pid, name=user.name, is_bot=False, token=_token("p"))
    for _ in range(req.bot_count):
        pid = secrets.token_hex(4)
        players[pid] = Player(player_id=pid, name=_rand_name("bot"), is_bot=True, token=_token("p"))
    game = Game(game_id=game_id, admin_token=admin_token, target_score=req.target_score, players=players)
    STORE.create_game(game)
    return CreateGameResponse(game_id=game.game_id, admin_token=game.admin_token, player_tokens={pid: p.token for pid, p in game.players.items()})

@app.post("/games/{game_id}/start", response_model=StartGameResponse)
def start_game(game_id: str, auth: AuthContext = Depends(get_auth)):
    if auth.role != "admin":
        raise HTTPException(status_code=403, detail="admin token required")
    game = auth.game
    if game.state in (GameState.RUNNING, GameState.FINISHED):
        return StartGameResponse(game_id=game.game_id, state=game.state, round=game.round)
    if game.state == GameState.ABANDONED:
        raise HTTPException(status_code=409, detail="game abandoned")
    if not game.players:
        raise HTTPException(status_code=400, detail="no players in game")
    game.state = GameState.RUNNING
    game.round = 0
    game.winner_id = None
    for p in game.players.values():
        p.score = 0
        p.eliminated = False
    return StartGameResponse(game_id=game.game_id, state=game.state, round=game.round)

@app.get("/games/{game_id}", response_model=PublicGameView)
def get_game_public(game_id: str):
    try:
        game = STORE.get(game_id)
    except KeyError:
        raise HTTPException(status_code=404, detail="game not found")
    return PublicGameView(game_id=game.game_id, state=game.state, round=game.round, target_score=game.target_score, scoreboard=game.public_scoreboard(), winner_id=game.winner_id)

@app.get("/games/{game_id}/players/{player_id}", response_model=PrivatePlayerStatus)
def get_player_private(
    game_id: str,
    player_id: str,
    auth: AuthContext = Depends(get_auth),
):
    game = auth.game
    player = game.players.get(player_id)
    if not player:
        raise HTTPException(status_code=404, detail="player not found")
    if auth.role == "player" and auth.player and auth.player.player_id != player_id:
        raise HTTPException(status_code=403, detail="players can only view their own status")
    if auth.role == "anonymous":
        raise HTTPException(status_code=401, detail="token required")
    return PrivatePlayerStatus(player_id=player.player_id, name=player.name, is_bot=player.is_bot, score=player.score, eliminated=player.eliminated)

@app.get("/games/{game_id}/players", response_model=List[PrivatePlayerStatus])
def list_players_admin(game_id: str, auth: AuthContext = Depends(get_auth)):
    if auth.role != "admin":
        raise HTTPException(status_code=403, detail="admin token required")
    game = auth.game
    return [PrivatePlayerStatus(player_id=p.player_id, name=p.name, is_bot=p.is_bot, score=p.score, eliminated=p.eliminated) for p in game.players.values()]

@app.post("/games/{game_id}/advance", response_model=AdvanceResponse)
def advance_round(game_id: str, auth: AuthContext = Depends(get_auth)):
    game = auth.game
    if game.state != GameState.RUNNING:
        raise HTTPException(status_code=409, detail=f"cannot advance when state={game.state}")
    if auth.role == "anonymous":
        raise HTTPException(status_code=401, detail="token required")
    game.round += 1
    rolls: Dict[str, int] = {}
    for p in game.players.values():
        if p.eliminated:
            continue
        roll = random.randint(1, 6)
        p.score += roll
        rolls[p.player_id] = roll
        if p.score >= game.target_score:
            game.state = GameState.FINISHED
            game.winner_id = p.player_id
            break
    return AdvanceResponse(game_id=game.game_id, state=game.state, round=game.round, rolls=rolls, winner_id=game.winner_id)

@app.post("/games/{game_id}/abandon", response_model=AbandonResponse)
def abandon_game(game_id: str, auth: AuthContext = Depends(get_auth)):
    if auth.role != "admin":
        raise HTTPException(status_code=403, detail="admin token required")
    game = auth.game
    if game.state in (GameState.FINISHED, GameState.ABANDONED):
        return AbandonResponse(game_id=game.game_id, state=game.state)
    game.state = GameState.ABANDONED
    return AbandonResponse(game_id=game.game_id, state=game.state)

HELP_TEXT = {
    "create": (
        "curl -s -X POST http://localhost:8000/games "
        "-H 'Content-Type: application/json' "
        "-d '{\"human_players\":[{\"name\":\"Alice\"},{\"name\":\"Bob\"}],\"bot_count\":1,\"target_score\":15}'"
    ),
    "start": "curl -s -X POST http://localhost:8000/games/REPLACE/start -H 'X-Auth-Token: ADMIN_TOKEN'",
    "advance": "curl -s -X POST http://localhost:8000/games/REPLACE/advance -H 'X-Auth-Token: ANY_PLAYER_OR_ADMIN_TOKEN'",
    "public": "curl -s http://localhost:8000/games/REPLACE",
    "player": "curl -s http://localhost:8000/games/REPLACE/players/PLAYER_ID -H 'X-Auth-Token: PLAYER_TOKEN'",
    "players_admin": "curl -s http://localhost:8000/games/REPLACE/players -H 'X-Auth-Token: ADMIN_TOKEN'",
    "abandon": "curl -s -X POST http://localhost:8000/games/REPLACE/abandon -H 'X-Auth-Token: ADMIN_TOKEN'",
}

@app.get("/help")
def help_routes():
    return {**HELP_TEXT, "mode": "api" if SSL_AVAILABLE else "compat-no-ssl"}

def _run_api_tests() -> dict:
    assert TestClient is not None, "TestClient unavailable"
    client = TestClient(app)  # type: ignore[arg-type]
    details: List[str] = []
    passed = 0
    r = client.post(
        "/games",
        json={
            "human_players": [{"name": "Alice"}, {"name": "Bob"}],
            "bot_count": 1,
            "target_score": 10,
        },
    )
    assert r.status_code == 200, r.text
    create_payload = r.json()
    details.append("create-game: 200")
    passed += 1
    gid = create_payload["game_id"]
    admin = create_payload["admin_token"]
    tokens = create_payload["player_tokens"]
    assert len(tokens) == 3
    details.append("create-game: 3 players ok")
    passed += 1
    r = client.post(f"/games/{gid}/start", headers={"X-Auth-Token": admin})
    assert r.status_code == 200
    assert r.json()["state"] == "running"
    details.append("start: admin can start")
    passed += 1
    some_player_token = next(iter(tokens.values()))
    r = client.post(f"/games/{gid}/start", headers={"X-Auth-Token": some_player_token})
    assert r.status_code == 403
    details.append("start: player forbidden ok")
    passed += 1
    r = client.get(f"/games/{gid}")
    assert r.status_code == 200
    assert r.json()["state"] in ("running", "finished")
    details.append("public: accessible")
    passed += 1
    player_id = next(iter(tokens.keys()))
    r = client.get(
        f"/games/{gid}/players/{player_id}", headers={"X-Auth-Token": some_player_token}
    )
    assert r.status_code == 200
    details.append("player-self: accessible")
    passed += 1
    other_pid = [pid for pid in tokens.keys() if pid != player_id][0]
    r = client.get(
        f"/games/{gid}/players/{other_pid}", headers={"X-Auth-Token": some_player_token}
    )
    assert r.status_code == 403
    details.append("player-other: forbidden ok")
    passed += 1
    r = client.post(f"/games/{gid}/advance", headers={"X-Auth-Token": some_player_token})
    assert r.status_code == 200
    assert "rolls" in r.json()
    details.append("advance: player can advance")
    passed += 1
    finished = False
    for _ in range(20):
        r = client.post(f"/games/{gid}/advance", headers={"X-Auth-Token": admin})
        if r.status_code == 200 and r.json()["state"] == "finished":
            finished = True
            break
    assert finished
    details.append("advance: game eventually finishes")
    passed += 1
    r2 = client.post(
        "/games",
        json={
            "human_players": [{"name": "H"}],
            "bot_count": 0,
            "target_score": 6,
        },
    )
    gid2 = r2.json()["game_id"]
    admin2 = r2.json()["admin_token"]
    client.post(f"/games/{gid2}/start", headers={"X-Auth-Token": admin2})
    r = client.post(f"/games/{gid2}/abandon", headers={"X-Auth-Token": admin2})
    assert r.status_code == 200 and r.json()["state"] == "abandoned"
    details.append("abandon: admin can abandon")
    passed += 1
    r = client.get(f"/games/{gid}/players/{player_id}")
    assert r.status_code == 401
    details.append("player-private: requires token (401)")
    passed += 1
    r3 = client.post(
        "/games",
        json={"human_players": [{"name": "X"}], "bot_count": 0, "target_score": 7},
    )
    gid3 = r3.json()["game_id"]
    tokX = r3.json()["admin_token"]
    r = client.post(f"/games/{gid3}/advance", headers={"X-Auth-Token": tokX})
    assert r.status_code == 409
    details.append("advance: blocked before start (409)")
    passed += 1
    return {"ok": True, "mode": "api", "tests_passed": passed, "details": details}

def _run_domain_tests() -> dict:
    details: List[str] = []
    passed = 0
    resp = create_game(
        CreateGameRequest(
            human_players=[NewPlayer(name="Alice"), NewPlayer(name="Bob")],
            bot_count=1,
            target_score=10,
        )
    )
    gid = resp.game_id
    admin = resp.admin_token
    tokens = resp.player_tokens
    assert len(tokens) == 3
    game = STORE.get(gid)
    details.append("create-game: domain ok (3 players)")
    passed += 1
    s = start_game(gid, auth=AuthContext(role="admin", game=game))
    assert s.state == GameState.RUNNING
    details.append("start: admin can start (domain)")
    passed += 1
    some_pid, some_tok = next(iter(tokens.items()))
    try:
        start_game(gid, auth=AuthContext(role="player", game=game, player=game.players[some_pid]))
        raise AssertionError("expected 403")
    except HTTPException as e:
        assert e.status_code == 403
    details.append("start: player forbidden (domain)")
    passed += 1
    pv = get_game_public(gid)
    assert pv.state in (GameState.RUNNING, GameState.FINISHED)
    details.append("public: accessible (domain)")
    passed += 1
    st = get_player_private(gid, some_pid, auth=AuthContext(role="player", game=game, player=game.players[some_pid]))
    assert st.player_id == some_pid
    details.append("player-self: accessible (domain)")
    passed += 1
    other_pid = [pid for pid in tokens.keys() if pid != some_pid][0]
    
